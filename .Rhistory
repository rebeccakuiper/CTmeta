#    stop(ErrorMessage)
#  }
#}else{
if(length(Lty) != nrLines){
ErrorMessage <- (paste0("The argument Lty should contain ", nrLines, " elements, that is, q*(q+1)/2 or the number of 1s in WhichElements (or WhichElements is incorrectly specified); not ", length(Lty)))
return(ErrorMessage)
stop(ErrorMessage)
}
#}
if(any(Lty %% 1 != 0)){
ErrorMessage <- (paste0("The argument Lty should consist of solely integers."))
return(ErrorMessage)
stop(ErrorMessage)
}
}
if(!is.null(Title)){
if(length(Title) != 1 & !is.list(Title)){
ErrorMessage <- (paste0("The argument Title should be a character or a list (containing at max 3 items)."))
return(ErrorMessage)
stop(ErrorMessage)
}
if(length(Title) > 3){
ErrorMessage <- (paste0("The list Title should at max contain 3 items. Currently, it consists of ", length(Title), " items."))
return(ErrorMessage)
stop(ErrorMessage)
}
# Option: Also check whether each element in list either a "call" or a 'character' is...
}
if(is.null(Labels)){
#subscripts = NULL
#for(i in 1:q){
#  subscripts = c(subscripts, paste0(i, 1:q, sep=""))
#}
subscripts = NULL
for(j in 1:q){
for(i in 1:q){
if(WhichElements[j,i] == 1){
subscripts = c(subscripts, paste0(j, i, sep=""))
}
}
}
legendT = NULL
for(i in 1:length(subscripts)){
e <- bquote(expression(ResidCorr[VAR](Delta[t])[.(subscripts[i])]))
legendT = c(legendT, eval(e))
}
if(AddGamma == 1){
legendG = NULL
for(i in 1:length(subscripts)){
e <- bquote(expression(Gamma["stand,"][.(subscripts[i])]))
legendG = c(legendG, eval(e))
}
legendT = c(legendT, legendG)
}
} else{
legendT <- as.vector(Labels)
}
if(is.null(Title)){
Title_1 <- expression(ResidCorr[VAR](Delta[t])~plot)
Title_2 <- "How do the VAR(1) residual correlations vary"
Title_3 <- "as a function of the time-interval"
}else{
Title_1 <- NULL
Title_2 <- NULL
if(length(Title) == 1){
if(is.list(Title)){
Title_3 <- Title[[1]]
}else{
Title_3 <- Title
}
}else if(length(Title) == 2){
Title_2 <- Title[[1]]
Title_3 <- Title[[2]]
}else if(length(Title) == 3){
Title_1 <- Title[[1]]
Title_2 <- Title[[2]]
Title_3 <- Title[[3]]
}
}
if(is.null(Col)){
Col_mx <- matrix(NA, ncol = q, nrow = q)
for(i in 1:q){
Col_mx[i, 1:q] <- i
}
Col <- t(Col_mx)[t(WhichTF)]
#Col <- as.vector(t(Col_mx))
#
#if(AddGamma == 1){
#  Col <- c(Col, Col)
#}
}
#
if(is.null(Lty)){
#There exist 5 'integer valued' line styles  besides the "solid" one.
#Hence, if there are more than 5 off-diagonals (i.e., q > 3), then use other way of specifying line styles.
Lty_mx <- matrix(NA, ncol = q, nrow = q)
if(q <= 3){
diag(Lty_mx) <- 1
Lty_mx[upper.tri(Lty_mx, diag = FALSE)] <- 2:(1+length(Lty_mx[upper.tri(Lty_mx, diag = FALSE)]))
Lty_mx[lower.tri(Lty_mx, diag = FALSE)] <- Lty_mx[upper.tri(Lty_mx, diag = FALSE)]
}else{
diag(Lty_mx) <- "solid"
for(i in 1:(q-1)){
for(j in (i+1):q){
Lty_mx[i,j] <- paste0(i,j)
}
}
Lty_mx[lower.tri(Lty_mx, diag = FALSE)] <- Lty_mx[upper.tri(Lty_mx, diag = FALSE)]
}
Lty <- t(Lty_mx)[t(WhichTF)]
#Lty <- as.vector(t(Lty_mx))
#
#if(AddGamma == 1){
#  Lty <- c(Lty, Lty)
#}
}
#
LWD_S <- 2.5
LWD_G <- 1
LWD_0 <- 1.5
if(AddGamma == 0){
LWD <- rep(LWD_S, length(Lty))
}else{
LWD <- c(rep(LWD_S, length(Lty)), rep(LWD_G, length(Lty)))
}
###
if(any(is.complex(eigen(Drift)$val))){
while (!is.null(dev.list()))  dev.off()  # to reset the graphics pars to defaults
# Multiple solutions, then 2x2 plots
op <- par(mfrow=c(2,2))
complex <- TRUE
#nf <- layout(matrix(c(1,2,5,3,4,6),2,3,byrow = TRUE), c(3,3,1), c(2,2,1), TRUE)
nf <- layout(matrix(c(1,2),1,2,byrow = TRUE), c(6), c(4,1), TRUE)
#layout.show(nf)
} else{
op <- par(mfrow=c(1,1))
complex <- FALSE
#
while (!is.null(dev.list()))  dev.off()  # to reset the graphics pars to defaults
par(mar=c(par('mar')[1:3], 0)) # optional, removes extraneous right inner margin space
plot.new()
l <- legend(0, 0,
legend = legendT, #cex=CEX,
bty = "n",
lty=Lty, # gives the legend appropriate symbols (lines)
lwd=LWD,
col=Col # gives the legend lines the correct color and width
)
# calculate right margin width in ndc
w <- 1.5 *( grconvertX(l$rect$w, to='ndc') - grconvertX(0, to='ndc') )
par(omd=c(0, 1-w, 0, 1))
#
}
q <- dim(Drift)[1]
DeltaTs<-seq(Min,Max,by=Step)
ResidCorrMxDeltaTs<-array(data=NA,dim=c(q,q,length(DeltaTs)))
if(length(Drift) == 1){ # Then, only one variance and thus corr = 1 (corr with itself)
# The function stopped at the beginning, when finding q = 1.
for(i in 1:length(DeltaTs)){
#SigmaVARDeltaTs <- Gamma - exp(Drift*DeltaTs[i]) * Gamma * t(exp(Drift*DeltaTs[i]))
ResidCorrMxDeltaTs[,,i] <- 1
}
}else{
for(i in 1:length(DeltaTs)){
# If DeltaTs[i] == 0, then chose something very small instead - better for plot
if(DeltaTs[i] == 0){
DeltaT_0 <- Step / 100
SigmaVARDeltaTs <- Gamma - expm(Drift*DeltaT_0) %*% Gamma %*% t(expm(Drift*DeltaT_0))
}else{
SigmaVARDeltaTs <- Gamma - expm(Drift*DeltaTs[i]) %*% Gamma %*% t(expm(Drift*DeltaTs[i]))
}
# In case there is another situation rendering the 0 matrix
if(all(SigmaVARDeltaTs == 0)){
ResidCorrMxDeltaTs[,,i] <- SigmaVARDeltaTs # 0 matrix, looks weird in plot
#ResidCorrMxDeltaTs[,,i] <- diag(q) # Identity mx
}else{
diagS <- diag(SigmaVARDeltaTs)
ResidCorrMx <- NULL
if(any(diagS < 0)){
ResidCorrMx <- "Since the DT residual covariance matrix has at least one negative diagonal element (i.e., negative residual variance) for at least one time interval, the corresponding DT residual correlation matrix 'ResidCorrMx' cannot be calculated nor plotted."
#print(ResidCorrMx)
# Btw possibly Sigma has at least one negative diagonal (as well), but Sigma is not per se determined here;
#     and I do not know whether there is one-to-one relationship for other DeltaT; therefore, I did not use this as first check (as well).
ErrorMessage <- ResidCorrMx
#cat(ErrorMessage)
#cat("\n")
return(list(ErrorMessage = ErrorMessage))
#stop(ErrorMessage)
stop()
}else{
S <- sqrt(diag(diagS))
ResidCorrMxDeltaTs[,,i] <- solve(S) %*% SigmaVARDeltaTs %*% solve(S)
}
}
}
# Gamma as correlation matrix = standardized Gamma:
Sxy <- sqrt(diag(diag(Gamma)))
Gamma_s <- solve(Sxy) %*% Gamma %*% solve(Sxy)
}
Xlab <- expression(Time-interval~(Delta[t]))
Ylab <- expression(ResidCorr[VAR](Delta[t])~values)
#
#wd <- getwd()
#dev.copy(png, filename = paste0(wd, "/www/ResidCorrMxPlot.png"))
teller <- 1
# Determine YLIM based on what to be plotted (and making sure 0 is in it)
# Elements to be plotted:
#WhichTF <- matrix(as.logical(WhichElements), q, q)
WhichTF_array <- array(WhichTF, dim = dim(ResidCorrMxDeltaTs))
EltsInPlot <- ResidCorrMxDeltaTs[WhichTF_array]
if(AddGamma == 1){
EltsGammaInPlot <- Gamma_s[WhichTF]
YLIM <- c(min(EltsInPlot, EltsGammaInPlot, 0), max(EltsInPlot, EltsGammaInPlot, 0))
}else{
YLIM <- c(min(EltsInPlot, 0), max(EltsInPlot, 0))
}
#YLIM=c(min(ResidCorrMxDeltaTs, Gamma_s), max(ResidCorrMxDeltaTs, Gamma_s))
plot(y=rep(0, length(DeltaTs)), x=DeltaTs, type="l", ylim=YLIM,
ylab = Ylab,
xlab = Xlab,
col=1000, lwd=LWD_0, lty=1,
main = mtext(side=3, line=2, adj=0, as.expression(Title_1)),
sub = mtext(side=3, line=c(1,0), adj=0, c(as.expression(Title_2), as.expression(Title_3)))
)
#
teller <- 0
for(j in 1:q){
#for(i in j:q){
for(i in 1:q){
if(WhichElements[j,i] == 1){
teller <- teller + 1
lines(y=ResidCorrMxDeltaTs[j,i,], x=DeltaTs, col=Col[teller], lwd=LWD_S, lty=Lty[teller])
if(AddGamma == 1){
lines(y=rep(Gamma_s[j,i], length(DeltaTs)), x = DeltaTs, col=Col[teller], lwd=LWD_G, lty=Lty[teller])
}
}
}
}
#Add lines for DiagDeltaT (if Diag == TRUE)
if(Diag == TRUE){
if(is.null(Phi)){
#Phi <- expm(Drift*DeltaT)
VarEst <- VARparam(DeltaT, Drift, Sigma)
Phi <- VarEst$Phi
SigmaVAR <- VarEst$SigmaVAR
}
DiagDt <- DiagDeltaT(Phi = Phi, SigmaVAR = SigmaVAR)
#DiagDt <- DiagDeltaT(Drift = Drift, Sigma = Sigma)
if(is.null(DiagDt$ErrorMessage)){ # TO DO werkt dit?
#if(is.null(DiagDt$DeltaT_diag != 0)){ # Do not use if 0, that means that there is no solution
DeltaT_DiagDt <- round(DiagDt$DeltaT_diag, 2)
if(DeltaT_DiagDt >= Min & DeltaT_DiagDt <= Max){
abline(v=DeltaT_DiagDt,
col="gray", lwd=LWD_0)
axis(side = 1, pos = (offset = YLIM[1]), DeltaT_DiagDt, cex.axis = .7, col.axis = "darkgray", col = "darkgray", lwd=LWD_0) # 3 = Add axis on top
}
#}
}else{
ErrorMessage <- DiagDt$ErrorMessage
return(ErrorMessage)
# TO DO is dit nu informatief?
# TO DO zegt nu:
# Error in DiagDt$ErrorMessage : $ operator is invalid for atomic vectors
}
}
if(complex == TRUE){
if(q<4){CEX = 1}else{CEX = (1.4-q/10)} # Check for optimal values!
par(mar = c(0,0,0,0))
plot.new()
legend(par('usr')[2], par('usr')[4], xpd=NA,
legend = legendT, cex=CEX,
bty = "n",
lty=Lty, # gives the legend appropriate symbols (lines)
lwd=LWD,
col=Col # gives the legend lines the correct color and width
)
}else{
if(q<4){CEX = 1}else{CEX = (1.4-q/10)} # Check for optimal values!
#
#legend("topright",
legend(par('usr')[2], par('usr')[4], xpd=NA,
legend = legendT, cex=CEX,
bty = "n",
lty=Lty, # gives the legend appropriate symbols (lines)
lwd=LWD,
col=Col # gives the legend lines the correct color and width
)
}
remove.packages("CTmeta")
#delete files in folder man
# Evt clear workspace
#restart ook R:
.rs.restartR()
#
library("devtools")
#devtools::install_github("klutometis/roxygen")
library(roxygen2)
NAME <- "CTmeta"
setwd(paste0("./", NAME))
document()
setwd("..")
install(NAME)
# 3 = do not update packages
?CTmeta
#
# De Haan Example
#
#library(CTmeta)
q <- 2
DeltaT <- 1
Phi_2 <- matrix(c(0.3540, -0.0482,
-0.0679, 0.2770), byrow = TRUE,
nrow = q, ncol = q)
Gamma_2 <- matrix(c(1, -0.5155,
-0.5155, 1),
nrow = q, ncol = q)
Phi_2
Gamma_2
#
#
# Make plots
ggPhiPlot(DeltaT, Phi_2, MaxMinPhi = TRUE)
SigmaVARPlot(DeltaT = 1, Phi = Phi_2, Gamma = Gamma_2)
ResidCorrMxPlot(DeltaT = 1, Phi = Phi_2, Gamma = Gamma_2)
#
library(CTmeta)
q <- 5
DeltaT <- 1
Phi_5 <- matrix(c(0.52, 0.22, 0.41, 0.22, 0.41,
0.11, 0.63, 0.21, 0.11, 0.41,
0.00, 0.00, 0.45, 0.00, 0.00,
0.00, 0.00, 0.00, 0.61, 0.00,
0.00, 0.00, 0.00, 0.00, 0.51), byrow = TRUE,
nrow = q, ncol = q)
SigmaVAR_5 <- diag(q)
Phi_5
SigmaVAR_5
#
PhiPlot(DeltaT, Phi_5)
ggPhiPlot(DeltaT, Phi_5)
#
# Determine DeltaT for which DT residual covariance matrix is diagonal
DiagDeltaT_5 <- DiagDeltaT(Phi = Phi_5, SigmaVAR = SigmaVAR_5)
#DiagDeltaT_5
DiagDeltaT_5$DeltaT_diag # = 1
#
# Calculate corresponding CT matrices, like CT residual correlation matrix
CTMpar <- CTMparam(DeltaT = 1, Phi = Phi_5, SigmaVAR = SigmaVAR_5)
CTMpar$Sigma
CTMpar$ResidCorrMx
# Calculate corresponding CT matrices, like CT residual correlation matrix
CTMpar <- CTMparam(DeltaT = 1, Phi = Phi_5, SigmaVAR = SigmaVAR_5)
#CTMpar$Sigma # off-diagonals neg or 0
CTMpar$ResidCorrMx # off-diagonals neg or 0
CTMpar$standGamma # off-diagonals positive or 0
# Hence, the residual correlations have to cross 0....
SigmaVARPlot(DeltaT = 1, Phi = Phi_5, SigmaVAR = SigmaVAR_5)
ResidCorrMxPlot(DeltaT = 1, Phi = Phi_5, SigmaVAR = SigmaVAR_5)
# Gaan idd ook maar 1x door nul en gaan idd door nul.
# START HIER github
remove.packages("CTmeta")
.rs.restartR()
library(devtools)
install_github("rebeccakuiper/CTmeta")
# 3 = do not update packages
library(CTmeta)
?nleqslv
??nleqslv
??uniroot
#install.packages("devtools")
library("devtools")
#install.packages("roxygen2")
##devtools::install_github("klutometis/roxygen")
## (C:/Users/Rebecca/Documents/R/win-library/3.6/...) # 4.0
## .rs.restartR()
library(roxygen2)
NAME <- "CTmeta"
#Step 4: Process your documentation
#Now you need to create the documentation from your annotations earlier. You've already done the "hard" work in Step 3. Step 4 is as easy doing this:
setwd(paste0("./", NAME))
document()
create(NAME)
#Step 4: Process your documentation
#Now you need to create the documentation from your annotations earlier. You've already done the "hard" work in Step 3. Step 4 is as easy doing this:
setwd(paste0("./", NAME))
document()
#Step 5: Install!
#  Now it is as simple as installing the package! You need to run this from the parent working directory that contains the cats folder.
setwd("..")
install(NAME)
#Now you have a real, live, functioning R package. For example, try typing ?cat_function. You should see the standard help page pop up!
#?CTMA
?CTmeta
library(CTmeta)
lsf.str("package:CTmeta") # Gives all functions. Note that the package must be attached.
lns = readLines("Input_Mod2.txt")
idx = grepl("#", lns)
Mod = as.matrix(read.table(text=lns[!idx], header = TRUE))
q <- 2
DeltaT <- matrix(c(2, 3, 1))
DeltaTStar <- 1
N <- matrix(c(643, 651, 473))
S <- length(N) #dim(N)[1]
Moderators = 0
Phi <- matrix(c(0.25, 0.10,
0.20, 0.36,
0.35, 0.20,
0.30, 0.46,
0.15, 0.00,
0.10, 0.26), byrow=T, ncol = q)
SigmaVAR_s <- diag(q) # for ease
SigmaVAR <- rbind(SigmaVAR_s, SigmaVAR_s, SigmaVAR_s)
# If Phi and SigmaVAR are known, one can calculate Gamma:
Gamma <- array(data=NA, dim=c(S*q,q))
teller <- 1
for(s in 1:S){
Gamma[teller:(teller+1),] <- Gamma.fromVAR(Phi[teller:(teller+1),], SigmaVAR[teller:(teller+1),])
teller <- teller + q
}
CTmeta(N, DeltaT, DeltaTStar, Phi, Gamma = Gamma)
# Check on errors:
#CTmeta(N=10, DeltaT=1, DeltaTStar=1, Phi = 0.25, Gamma = 2)
CTmeta(N=10, DeltaT, DeltaTStar, Phi, Gamma)
CTmeta(N, DeltaT=1, DeltaTStar, Phi, Gamma)
CTmeta(N, DeltaT, DeltaTStar=c(1,1), Phi, Gamma)
q <- 2
DeltaT <- matrix(c(2, 3, 1))
DeltaTStar <- 1
N <- matrix(c(643, 651, 473))
S <- length(N) #dim(N)[1]
Moderators = 0
Phi <- matrix(c(0.25, 0.10,
0.20, 0.36,
0.35, 0.20,
0.30, 0.46,
0.15, 0.00,
0.10, 0.26), byrow=T, ncol = q)
SigmaVAR_s <- diag(q) # for ease
SigmaVAR <- rbind(SigmaVAR_s, SigmaVAR_s, SigmaVAR_s)
# If Phi and SigmaVAR are known, one can calculate Gamma:
Gamma <- array(data=NA, dim=c(S*q,q))
teller <- 1
for(s in 1:S){
Gamma[teller:(teller+1),] <- Gamma.fromVAR(Phi[teller:(teller+1),], SigmaVAR[teller:(teller+1),])
teller <- teller + q
}
CTmeta(N, DeltaT, DeltaTStar, Phi, Gamma = Gamma)
# Check on errors:
#CTmeta(N=10, DeltaT=1, DeltaTStar=1, Phi = 0.25, Gamma = 2)
CTmeta(N=10, DeltaT, DeltaTStar, Phi, Gamma)
CTmeta(N, DeltaT=1, DeltaTStar, Phi, Gamma)
CTmeta(N, DeltaT, DeltaTStar=c(1,1), Phi, Gamma)
CTmeta(N, DeltaT, DeltaTStar, Phi = 0.25, Gamma)
# No moderators - no RE
CTmeta(N, DeltaT, DeltaTStar, Phi, SigmaVAR, Gamma, Moderators, Mod, 1)
CTmeta(N, DeltaT, DeltaTStar, Phi, SigmaVAR, Gamma, Moderators, Mod)
CTmeta(N, DeltaT, DeltaTStar, Phi, SigmaVAR, Gamma, Moderators)
CTmeta(N, DeltaT, DeltaTStar, Phi, SigmaVAR, Gamma)
CTmeta(N, DeltaT, DeltaTStar, Phi, SigmaVAR)
CTmeta(N, DeltaT, DeltaTStar, Phi, SigmaVAR = SigmaVAR)
#CTmeta(N, DeltaT, DeltaTStar, Phi, Gamma) # Now, CTmeta incorrectly uses SigmaVAR = Gamma!
CTmeta(N, DeltaT, DeltaTStar, Phi, Gamma = Gamma)
CTmeta(N, DeltaT, DeltaTStar, Phi, NULL, Gamma)
# No moderators - BUT RE
CTmeta(N, DeltaT, DeltaTStar, Phi, SigmaVAR, Gamma, Moderators, Mod, 2) # Only in this case, one does not need to explictely specify 'FEorRE = '
# START HIER
remove.packages("CTmeta")
#delete files in folder man
# Evt clear workspace
#restart ook R:
.rs.restartR()
#
library("devtools")
#devtools::install_github("klutometis/roxygen")
library(roxygen2)
NAME <- "CTmeta"
setwd(paste0("./", NAME))
document()
setwd("..")
install(NAME)
# 3 = do not update packages
?CTmeta
#
#library(CTmeta)
?Area
?ChecksCTM
q <- 2
DeltaT <- matrix(c(2, 3, 1))
DeltaTStar <- 1
N <- matrix(c(643, 651, 473))
S <- length(N) #dim(N)[1]
Moderators = 0
Phi <- matrix(c(0.25, 0.10,
0.20, 0.36,
0.35, 0.20,
0.30, 0.46,
0.15, 0.00,
0.10, 0.26), byrow=T, ncol = q)
SigmaVAR_s <- diag(q) # for ease
SigmaVAR <- rbind(SigmaVAR_s, SigmaVAR_s, SigmaVAR_s)
# If Phi and SigmaVAR are known, one can calculate Gamma:
Gamma <- array(data=NA, dim=c(S*q,q))
teller <- 1
for(s in 1:S){
Gamma[teller:(teller+1),] <- Gamma.fromVAR(Phi[teller:(teller+1),], SigmaVAR[teller:(teller+1),])
teller <- teller + q
}
#
CTma <- CTmeta(N, DeltaT, DeltaTStar, Phi, Gamma = Gamma)
CTma
print(CTma)
CTma
